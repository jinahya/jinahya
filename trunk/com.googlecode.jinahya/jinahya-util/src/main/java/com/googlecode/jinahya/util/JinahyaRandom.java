/*
 * Copyright 2011 Jin Kwon <jinahya at gmail.com>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.googlecode.jinahya.util;


import java.util.Random;


/**
 *
 * @author Jin Kwon <jinahya at gmail.com>
 */
public class JinahyaRandom extends Random {


    /** GENERATED. */
    private static final long serialVersionUID = 4093243768555129124L;


    /**
     * Creates a new instance.
     */
    public JinahyaRandom() {
        super();
    }


    /**
     * Generates a byte array in given <code>length</code>.
     *
     * @param length array length
     * @param nullable nullable flag
     * @return generated byte array or null if <code>nullable</code> is set
     */
    public byte[] nextBytes(final int length, final boolean nullable) {

        return nextBytes(length, length, nullable);
    }


    /**
     * Generates a byte array in arbitrary length.
     *
     * @param minimumLength minimum byte array length (inclusive)
     * @param maximumLength maximum byte array length (inclusive)
     * @param nullable nullable flag
     * @return generated bytes or null if <code>nullable</code> is set
     */
    public byte[] nextBytes(final int minimumLength, final int maximumLength,
                            final boolean nullable) {


        if (minimumLength < 0) {
            throw new IllegalArgumentException(
                "minimumLength(" + minimumLength + ") < 0");
        }

        if (maximumLength < minimumLength) {
            throw new IllegalArgumentException(
                "maximumLength(" + maximumLength + ") < minimumLength("
                + minimumLength + ")");
        }

        if (nullable && nextBoolean()) {
            return null;
        }

        final int length = (minimumLength == maximumLength
                            ? 0 : nextInt(maximumLength - minimumLength))
                           + minimumLength;
        final byte[] bytes = new byte[length];
        nextBytes(bytes);
        return bytes;
    }


    /**
     * Generates a 31-bit unsigned Integer.
     *
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Integer nextUnsignedInt(final boolean nullable) {
        return nextUnsignedInt(Integer.SIZE - 1, nullable);
    }


    /**
     * Generates an <code>length</code>-bit unsigned Integer.
     *
     * @param maximumBits maximum bits between 1 (inclusive) and 32 (exclusive).
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Integer nextUnsignedInt(final int maximumBits,
                                   final boolean nullable) {

        if (maximumBits < 0x01) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") < 0x01");
        }

        if (maximumBits >= Integer.SIZE) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") >= " + Integer.SIZE);
        }

        if (nullable && nextBoolean()) {
            return null;
        }

        return nextInt() >>> (Integer.SIZE - (nextInt(maximumBits) + 1));
    }


    /**
     * Generates a 32-bit signed Integer.
     *
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set
     */
    public Integer nextInt(final boolean nullable) {
        return nextInt(Integer.SIZE, nullable);
    }


    /**
     * Generates an <code>length</code>-bit signed Integer.
     *
     * @param maximumBits maximum bits between 1 (exclusive) and 32 (inclusive).
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Integer nextInt(final int maximumBits, final boolean nullable) {



        if (maximumBits <= 0x01) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") <= 0x01");
        }

        if (maximumBits > Integer.SIZE) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") > " + Integer.SIZE);
        }

        if (nullable && nextBoolean()) {
            return null;
        }

        final int nextInt = nextInt();

        if (maximumBits == Integer.SIZE) {
            return nextInt;
        }

        return nextInt >> (Integer.SIZE - (nextInt(maximumBits) + 1));
    }


    /**
     * Generates a 31-bit unsigned Integer.
     *
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Long nextUnsignedLong(final boolean nullable) {
        return nextUnsignedLong(Long.SIZE - 1, nullable);
    }


    /**
     * Generates an <code>length</code>-bit unsigned Integer.
     *
     * @param maximumBits maximum bits between 1 (inclusive) and 32 (exclusive).
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Long nextUnsignedLong(final int maximumBits,
                                 final boolean nullable) {

        if (maximumBits < 0x01) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") < 0x01");
        }

        if (maximumBits >= Long.SIZE) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") >= " + Long.SIZE);
        }

        if (nullable && nextBoolean()) {
            return null;
        }

        return nextLong() >>> (Long.SIZE - (nextInt(maximumBits) + 1));
    }


    /**
     * Generates a 32-bit signed Long.
     *
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set
     */
    public Long nextLong(final boolean nullable) {
        return nextLong(Long.SIZE, nullable);
    }


    /**
     * Generates an <code>length</code>-bit signed Long.
     *
     * @param maximumBits maximum bits between 1 (exclusive) and 64 (inclusive).
     * @param nullable nullable flag
     * @return generated value or null if <code>nullable</code> is set.
     */
    public Long nextLong(final int maximumBits, final boolean nullable) {



        if (maximumBits <= 0x01) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") <= 0x01");
        }

        if (maximumBits > Long.SIZE) {
            throw new IllegalArgumentException(
                "maximumBits(" + maximumBits + ") > " + Long.SIZE);
        }

        if (nullable && nextBoolean()) {
            return null;
        }

        final long nextLong = nextLong();

        if (maximumBits == Long.SIZE) {
            return nextLong;
        }

        return nextLong >> (Long.SIZE - (nextInt(maximumBits) + 1));
    }


}

