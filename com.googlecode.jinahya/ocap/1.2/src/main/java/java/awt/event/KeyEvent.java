/*
</p>
<a name="notice"><strong><center>
NOTICE
</center></strong><br>
<br>

(c) 2005-2007 Sun Microsystems, Inc. All Rights Reserved.
<p>
Neither this file nor any files generated from it describe a complete
specification, and they may only be used as described below. For
example, no permission is given for you to incorporate this file, in
whole or in part, in an implementation of a Java specification.
<p>
Sun Microsystems Inc. owns the copyright in this file and it is provided
to you for informative, as opposed to normative, use. The file and any
files generated from it may be used to generate other informative
documentation, such as a unified set of documents of API signatures for
a platform that includes technologies expressed as Java APIs. The file
may also be used to produce "compilation stubs," which allow
applications to be compiled and validated for such platforms.
<p>
Any work generated from this file, such as unified javadocs or compiled
stub files, must be accompanied by this notice in its entirety.
<p>
This work corresponds to the API signatures of JSR 217: Personal Basis
Profile 1.1. In the event of a discrepency between this work and the
JSR 217 specification, which is available at
http://www.jcp.org/en/jsr/detail?id=217, the latter takes precedence.
*/


  


package java.awt.event;

// import java.awt.Event;
import java.awt.Component;
import java.awt.GraphicsEnvironment;
import java.awt.Toolkit;
import java.io.IOException;
import java.io.ObjectInputStream;

/** 
 * An event which indicates that a keystroke occurred in a component.
 * <p>
 * This low-level event is generated by a component object (such as a text 
 * field) when a key is pressed, released, or typed.  
 * The event is passed to every <code>KeyListener</code>
 * or <code>KeyAdapter</code> object which registered to receive such
 * events using the component's <code>addKeyListener</code> method.
 * (<code>KeyAdapter</code> objects implement the 
 * <code>KeyListener</code> interface.)  Each such listener object 
 * gets this <code>KeyEvent</code> when the event occurs.
 *
 * <p>
 * <em>"Key typed" events</em> are higher-level and generally do not depend on 
 * the platform or keyboard layout.  They are generated when a Unicode character 
 * is entered, and are the preferred way to find out about character input.
 * In the simplest case, a key typed event is produced by a single key press 
 * (e.g., 'a').  Often, however, characters are produced by series of key 
 * presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to 
 * key typed events may be many-to-one or many-to-many.  Key releases are not 
 * usually necessary to generate a key typed event, but there are some cases 
 * where the key typed event is not generated until a key is released (e.g., 
 * entering ASCII sequences via the Alt-Numpad method in Windows).  
 * No key typed events are generated for keys that don't generate Unicode 
 * characters (e.g., action keys, modifier keys, etc.).
 * The getKeyChar method always returns a valid Unicode character or 
 * CHAR_UNDEFINED.  
 * For key pressed and key released events, the getKeyCode method returns 
 * the event's keyCode.  For key typed events, the getKeyCode method 
 * always returns VK_UNDEFINED.
 *
 * <p>
 * <em>"Key pressed" and "key released" events</em> are lower-level and depend 
 * on the platform and keyboard layout. They are generated whenever a key is 
 * pressed or released, and are the only way to find out about keys that don't 
 * generate character input (e.g., action keys, modifier keys, etc.). The key 
 * being pressed or released is indicated by the getKeyCode method, which returns 
 * a virtual key code.
 *
 * <p>
 * <em>Virtual key codes</em> are used to report which keyboard key has
 * been pressed, rather than a character generated by the combination
 * of one or more keystrokes (such as "A", which comes from shift and "a").  
 *
 * <p>
 * For example, pressing the Shift key will cause a KEY_PRESSED event 
 * with a VK_SHIFT keyCode, while pressing the 'a' key will result in 
 * a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event 
 * will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar 
 * value of 'A' is generated.
 *
 * <p>
 * Notes:
 * <ul>
 * <li>Key combinations which do not result in Unicode characters, such as action 
 * keys like F1 and the HELP key, do not generate KEY_TYPED events.
 * <li>Not all keyboards or systems are capable of generating all
 * virtual key codes.  No attempt is made in Java to generate these keys 
 * artificially. 
 * <li>Virtual key codes do not identify a physical key: they depend on the
 * platform and keyboard layout. For example, the key that generates VK_Q 
 * when using a U.S. keyboard layout will generate VK_A when using a French 
 * keyboard layout.
 * <li>Not all characters have a keycode associated with them.  For example, 
 * there is no keycode for the question mark because there is no keyboard 
 * for which it appears on the primary layer.  
 * <li>In order to support the platform-independent handling of action keys,
 * the Java platform uses a few additional virtual key constants for functions
 * that would otherwise have to be recognized by interpreting virtual key codes
 * and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES
 * is returned instead of VK_CONVERT with the ALT modifier.
 * </ul>
 *
 * <p>
 * WARNING: Aside from those keys that are defined by the Java language
 * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
 * constants.  Sun reserves the right to change these values as needed
 * to accomodate a wider range of keyboards in the future.  
 *
<!-- PBP/PP -->
 * <p>
 * <a name="restrictions">
 * <h4>Restrictions</h4>
 * <em>
 * Implementations of this Profile exhibit certain restrictions with respect
 * to key events, specifically:
 * <ul>
 * <li> An implementation need not provide full support for the generation of
 * key events.  In such a case, it may partially support the generation of
 * key events or not support them at all.
 * <p>
 * Regardless of this restriction, applications may still
 * create KeyEvent objects and post them to the system event queue.
 * </ul>
 * Note: An implementation that provides full support for key events must
 * support a <a href="doc-files/basic-keys.html">basic set of virtual key
 * codes</a>.
 * <p>
 * For more information, see <a href="../../../doc-files/properties.html">Profile-specific properties</a>.
 * </em>
 * @author Carl Quinn
 * @author Amy Fowler
 * @author Norbert Lindenberg
 * @version 1.65 01/23/03
 *
 * @see KeyAdapter
 * @see KeyListener
 * @see <a href="http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial: Writing a Key Listener</a>
 * @see <a href="http://www.awl.com/cp/javaseries/jcl1_2.html">Reference: The Java Class Libraries (update file)</a>
 *
 * @since 1.1
 */
public class KeyEvent extends InputEvent
{
    /** 
     * The first number in the range of ids used for key events.
     */
    public static final int KEY_FIRST = 400;

    /** 
     * The last number in the range of ids used for key events.
     */
    public static final int KEY_LAST = 402;

    /** 
     * The "key typed" event.  This event is generated when a character is
     * entered.  In the simplest case, it is produced by a single key press.  
     * Often, however, characters are produced by series of key presses, and 
     * the mapping from key pressed events to key typed events may be 
     * many-to-one or many-to-many.  
     */
    public static final int KEY_TYPED = KEY_FIRST;

    /** 
     * The "key pressed" event. This event is generated when a key
     * is pushed down.
     */
    public static final int KEY_PRESSED = 1 + KEY_FIRST;

    /** 
     * The "key released" event. This event is generated when a key
     * is let up.
     */
    public static final int KEY_RELEASED = 2 + KEY_FIRST;

    public static final int VK_ENTER = '\n';

    public static final int VK_BACK_SPACE = '\b';

    public static final int VK_TAB = '\t';

    public static final int VK_CANCEL = 0x03;

    public static final int VK_CLEAR = 0x0C;

    public static final int VK_SHIFT = 0x10;

    public static final int VK_CONTROL = 0x11;

    public static final int VK_ALT = 0x12;

    public static final int VK_PAUSE = 0x13;

    public static final int VK_CAPS_LOCK = 0x14;

    public static final int VK_ESCAPE = 0x1B;

    public static final int VK_SPACE = 0x20;

    public static final int VK_PAGE_UP = 0x21;

    public static final int VK_PAGE_DOWN = 0x22;

    public static final int VK_END = 0x23;

    public static final int VK_HOME = 0x24;

    /** 
     * Constant for the non-numpad <b>left</b> arrow key.
     * @see #VK_KP_LEFT
     */
    public static final int VK_LEFT = 0x25;

    /** 
     * Constant for the non-numpad <b>up</b> arrow key.
     * @see #VK_KP_UP
     */
    public static final int VK_UP = 0x26;

    /** 
     * Constant for the non-numpad <b>right</b> arrow key.
     * @see #VK_KP_RIGHT
     */
    public static final int VK_RIGHT = 0x27;

    /** 
     * Constant for the non-numpad <b>down</b> arrow key.
     * @see #VK_KP_DOWN
     */
    public static final int VK_DOWN = 0x28;

    public static final int VK_COMMA = 0x2C;

    /** 
     * Constant for the "-" key.
     * @since 1.2
     */
    public static final int VK_MINUS = 0x2D;

    public static final int VK_PERIOD = 0x2E;

    public static final int VK_SLASH = 0x2F;

    /** VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39)  */
    public static final int VK_0 = 0x30;

    public static final int VK_1 = 0x31;

    public static final int VK_2 = 0x32;

    public static final int VK_3 = 0x33;

    public static final int VK_4 = 0x34;

    public static final int VK_5 = 0x35;

    public static final int VK_6 = 0x36;

    public static final int VK_7 = 0x37;

    public static final int VK_8 = 0x38;

    public static final int VK_9 = 0x39;

    public static final int VK_SEMICOLON = 0x3B;

    public static final int VK_EQUALS = 0x3D;

    /** VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
    public static final int VK_A              = 0x41;
    public static final int VK_B              = 0x42;
    public static final int VK_C              = 0x43;
    public static final int VK_D              = 0x44;
    public static final int VK_E              = 0x45;
    public static final int VK_F              = 0x46;
    public static final int VK_G              = 0x47;
    public static final int VK_H              = 0x48;
    public static final int VK_I              = 0x49;
    public static final int VK_J              = 0x4A;
    public static final int VK_K              = 0x4B;
    public static final int VK_L              = 0x4C;
    public static final int VK_M              = 0x4D;
    public static final int VK_N              = 0x4E;
    public static final int VK_O              = 0x4F;
    public static final int VK_P              = 0x50;
    public static final int VK_Q              = 0x51;
    public static final int VK_R              = 0x52;
    public static final int VK_S              = 0x53;
    public static final int VK_T              = 0x54;
    public static final int VK_U              = 0x55;
    public static final int VK_V              = 0x56;
    public static final int VK_W              = 0x57;
    public static final int VK_X              = 0x58;
    public static final int VK_Y              = 0x59;
    public static final int VK_Z              = 0x5A;

    public static final int VK_OPEN_BRACKET   = 0x5B;
    public static final int VK_BACK_SLASH     = 0x5C;
    public static final int VK_CLOSE_BRACKET  = 0x5D;

    public static final int VK_NUMPAD0        = 0x60;
    public static final int VK_NUMPAD1        = 0x61;
    public static final int VK_NUMPAD2        = 0x62;
    public static final int VK_NUMPAD3        = 0x63;
    public static final int VK_NUMPAD4        = 0x64;
    public static final int VK_NUMPAD5        = 0x65;
    public static final int VK_NUMPAD6        = 0x66;
    public static final int VK_NUMPAD7        = 0x67;
    public static final int VK_NUMPAD8        = 0x68;
    public static final int VK_NUMPAD9        = 0x69;
    public static final int VK_MULTIPLY       = 0x6A;
    public static final int VK_ADD            = 0x6B;


    /** 
     * This constant is obsolete, and is included only for backwards
     * compatibility.
     * @see #VK_SEPARATOR
     */
    public static final int VK_SEPARATER      = 0x6C;

    /** 
     * Constant for the Numpad Separator key. 
     * @since 1.4
     */
    public static final int VK_SEPARATOR      = VK_SEPARATER;

    public static final int VK_SUBTRACT       = 0x6D;
    public static final int VK_DECIMAL        = 0x6E;
    public static final int VK_DIVIDE         = 0x6F;
    public static final int VK_DELETE         = 0x7F; /* ASCII DEL */
    public static final int VK_NUM_LOCK       = 0x90;
    public static final int VK_SCROLL_LOCK    = 0x91;

    /** Constant for the F1 function key. */
    public static final int VK_F1             = 0x70;

    /** Constant for the F2 function key. */
    public static final int VK_F2             = 0x71;

    /** Constant for the F3 function key. */
    public static final int VK_F3             = 0x72;

    /** Constant for the F4 function key. */
    public static final int VK_F4             = 0x73;

    /** Constant for the F5 function key. */
    public static final int VK_F5             = 0x74;

    /** Constant for the F6 function key. */
    public static final int VK_F6             = 0x75;

    /** Constant for the F7 function key. */
    public static final int VK_F7             = 0x76;

    /** Constant for the F8 function key. */
    public static final int VK_F8             = 0x77;

    /** Constant for the F9 function key. */
    public static final int VK_F9             = 0x78;

    /** Constant for the F10 function key. */
    public static final int VK_F10            = 0x79;

    /** Constant for the F11 function key. */
    public static final int VK_F11            = 0x7A;

    /** Constant for the F12 function key. */
    public static final int VK_F12            = 0x7B;
    
    /**
     * Constant for the F13 function key.
     * @since 1.2
     */
    /* F13 - F24 are used on IBM 3270 keyboard; use random range for constants. */
    public static final int VK_F13            = 0xF000;
 
    /**
     * Constant for the F14 function key.
     * @since 1.2
     */
    public static final int VK_F14            = 0xF001;
 
    /**
     * Constant for the F15 function key.
     * @since 1.2
     */
    public static final int VK_F15            = 0xF002;
 
    /**
     * Constant for the F16 function key.
     * @since 1.2
     */
    public static final int VK_F16            = 0xF003;
 
    /**
     * Constant for the F17 function key.
     * @since 1.2
     */
    public static final int VK_F17            = 0xF004;
 
    /**
     * Constant for the F18 function key.
     * @since 1.2
     */
    public static final int VK_F18            = 0xF005;
 
    /**
     * Constant for the F19 function key.
     * @since 1.2
     */
    public static final int VK_F19            = 0xF006;
 
    /**
     * Constant for the F20 function key.
     * @since 1.2
     */
    public static final int VK_F20            = 0xF007;
 
    /**
     * Constant for the F21 function key.
     * @since 1.2
     */
    public static final int VK_F21            = 0xF008;
 
    /**
     * Constant for the F22 function key.
     * @since 1.2
     */
    public static final int VK_F22            = 0xF009;
 
    /**
     * Constant for the F23 function key.
     * @since 1.2
     */
    public static final int VK_F23            = 0xF00A;
 
    /**
     * Constant for the F24 function key.
     * @since 1.2
     */
    public static final int VK_F24            = 0xF00B;

    public static final int VK_PRINTSCREEN    = 0x9A;
    public static final int VK_INSERT         = 0x9B;
    public static final int VK_HELP           = 0x9C;
    public static final int VK_META           = 0x9D;

    public static final int VK_BACK_QUOTE     = 0xC0;
    public static final int VK_QUOTE          = 0xDE;

    /**
     * Constant for the numeric keypad <b>up</b> arrow key.
     * @see #VK_UP
     * @since 1.2
     */
    public static final int VK_KP_UP          = 0xE0;

    /**
     * Constant for the numeric keypad <b>down</b> arrow key.
     * @see #VK_DOWN
     * @since 1.2
     */
    public static final int VK_KP_DOWN        = 0xE1;

    /**
     * Constant for the numeric keypad <b>left</b> arrow key.
     * @see #VK_LEFT
     * @since 1.2
     */
    public static final int VK_KP_LEFT        = 0xE2;

    /**
     * Constant for the numeric keypad <b>right</b> arrow key.
     * @see #VK_RIGHT
     * @since 1.2
     */
    public static final int VK_KP_RIGHT       = 0xE3;

    /* For European keyboards */
    /** @since 1.2 */
    public static final int VK_DEAD_GRAVE               = 0x80;
    /** @since 1.2 */
    public static final int VK_DEAD_ACUTE               = 0x81;
    /** @since 1.2 */
    public static final int VK_DEAD_CIRCUMFLEX          = 0x82;
    /** @since 1.2 */
    public static final int VK_DEAD_TILDE               = 0x83;
    /** @since 1.2 */
    public static final int VK_DEAD_MACRON              = 0x84;
    /** @since 1.2 */
    public static final int VK_DEAD_BREVE               = 0x85;
    /** @since 1.2 */
    public static final int VK_DEAD_ABOVEDOT            = 0x86;
    /** @since 1.2 */
    public static final int VK_DEAD_DIAERESIS           = 0x87;
    /** @since 1.2 */
    public static final int VK_DEAD_ABOVERING           = 0x88;
    /** @since 1.2 */
    public static final int VK_DEAD_DOUBLEACUTE         = 0x89;
    /** @since 1.2 */
    public static final int VK_DEAD_CARON               = 0x8a;
    /** @since 1.2 */
    public static final int VK_DEAD_CEDILLA             = 0x8b;
    /** @since 1.2 */
    public static final int VK_DEAD_OGONEK              = 0x8c;
    /** @since 1.2 */
    public static final int VK_DEAD_IOTA                = 0x8d;
    /** @since 1.2 */
    public static final int VK_DEAD_VOICED_SOUND        = 0x8e;
    /** @since 1.2 */
    public static final int VK_DEAD_SEMIVOICED_SOUND    = 0x8f;

    /** @since 1.2 */
    public static final int VK_AMPERSAND                = 0x96;
    /** @since 1.2 */
    public static final int VK_ASTERISK                 = 0x97;
    /** @since 1.2 */
    public static final int VK_QUOTEDBL                 = 0x98;
    /** @since 1.2 */
    public static final int VK_LESS                     = 0x99;

    /** @since 1.2 */
    public static final int VK_GREATER                  = 0xa0;
    /** @since 1.2 */
    public static final int VK_BRACELEFT                = 0xa1;
    /** @since 1.2 */
    public static final int VK_BRACERIGHT               = 0xa2;

    /**
     * Constant for the "@" key.
     * @since 1.2
     */
    public static final int VK_AT                       = 0x0200;
 
    /**
     * Constant for the ":" key.
     * @since 1.2
     */
    public static final int VK_COLON                    = 0x0201;
 
    /**
     * Constant for the "^" key.
     * @since 1.2
     */
    public static final int VK_CIRCUMFLEX               = 0x0202;
 
    /**
     * Constant for the "$" key.
     * @since 1.2
     */
    public static final int VK_DOLLAR                   = 0x0203;
 
    /**
     * Constant for the Euro currency sign key.
     * @since 1.2
     */
    public static final int VK_EURO_SIGN                = 0x0204;
 
    /**
     * Constant for the "!" key.
     * @since 1.2
     */
    public static final int VK_EXCLAMATION_MARK         = 0x0205;
 
    /**
     * Constant for the inverted exclamation mark key.
     * @since 1.2
     */
    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
 
    /**
     * Constant for the "(" key.
     * @since 1.2
     */
    public static final int VK_LEFT_PARENTHESIS         = 0x0207;
 
    /**
     * Constant for the "#" key.
     * @since 1.2
     */
    public static final int VK_NUMBER_SIGN              = 0x0208;
 
    /**
     * Constant for the "+" key.
     * @since 1.2
     */
    public static final int VK_PLUS                     = 0x0209;

    /**
     * Constant for the ")" key.
     * @since 1.2
     */
    public static final int VK_RIGHT_PARENTHESIS        = 0x020A;
 
    /**
     * Constant for the "_" key.
     * @since 1.2
     */
    public static final int VK_UNDERSCORE               = 0x020B;
 
    /* for input method support on Asian Keyboards */

    /* not clear what this means - listed in Microsoft Windows API */
    public static final int VK_FINAL                    = 0x0018;
    
    /** Constant for the Convert function key. */
    /* Japanese PC 106 keyboard, Japanese Solaris keyboard: henkan */
    public static final int VK_CONVERT                  = 0x001C;

    /** Constant for the Don't Convert function key. */
    /* Japanese PC 106 keyboard: muhenkan */
    public static final int VK_NONCONVERT               = 0x001D;
    
    /** Constant for the Accept or Commit function key. */
    /* Japanese Solaris keyboard: kakutei */
    public static final int VK_ACCEPT                   = 0x001E;

    /* not clear what this means - listed in Microsoft Windows API */
    public static final int VK_MODECHANGE               = 0x001F;

    /* replaced by VK_KANA_LOCK for Microsoft Windows and Solaris; 
       might still be used on other platforms */
    public static final int VK_KANA                     = 0x0015;

    /* replaced by VK_INPUT_METHOD_ON_OFF for Microsoft Windows and Solaris; 
       might still be used for other platforms */
    public static final int VK_KANJI                    = 0x0019;

    /**
     * Constant for the Alphanumeric function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: eisuu */
    public static final int VK_ALPHANUMERIC             = 0x00F0;
 
    /**
     * Constant for the Katakana function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: katakana */
    public static final int VK_KATAKANA                 = 0x00F1;
 
    /**
     * Constant for the Hiragana function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: hiragana */
    public static final int VK_HIRAGANA                 = 0x00F2;
 
    /**
     * Constant for the Full-Width Characters function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: zenkaku */
    public static final int VK_FULL_WIDTH               = 0x00F3;
 
    /**
     * Constant for the Half-Width Characters function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: hankaku */
    public static final int VK_HALF_WIDTH               = 0x00F4;
 
    /**
     * Constant for the Roman Characters function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard: roumaji */
    public static final int VK_ROMAN_CHARACTERS         = 0x00F5;
 
    /**
     * Constant for the All Candidates function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_CONVERT + ALT: zenkouho */
    public static final int VK_ALL_CANDIDATES           = 0x0100;
 
    /**
     * Constant for the Previous Candidate function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_CONVERT + SHIFT: maekouho */
    public static final int VK_PREVIOUS_CANDIDATE       = 0x0101;
 
    /**
     * Constant for the Code Input function key.
     * @since 1.2
     */
    /* Japanese PC 106 keyboard - VK_ALPHANUMERIC + ALT: kanji bangou */
    public static final int VK_CODE_INPUT               = 0x0102;
 
    /**
     * Constant for the Japanese-Katakana function key.
     * This key switches to a Japanese input method and selects its Katakana input mode.
     * @since 1.2
     */
    /* Japanese Macintosh keyboard - VK_JAPANESE_HIRAGANA + SHIFT */
    public static final int VK_JAPANESE_KATAKANA        = 0x0103;
 
    /**
     * Constant for the Japanese-Hiragana function key.
     * This key switches to a Japanese input method and selects its Hiragana input mode.
     * @since 1.2
     */
    /* Japanese Macintosh keyboard */
    public static final int VK_JAPANESE_HIRAGANA        = 0x0104;
 
    /**
     * Constant for the Japanese-Roman function key.
     * This key switches to a Japanese input method and selects its Roman-Direct input mode.
     * @since 1.2
     */
    /* Japanese Macintosh keyboard */
    public static final int VK_JAPANESE_ROMAN           = 0x0105;

    /**
     * Constant for the locking Kana function key.
     * This key locks the keyboard into a Kana layout.
     * @since 1.3
     */
    /* Japanese PC 106 keyboard with special Windows driver - eisuu + Control; Japanese Solaris keyboard: kana */
    public static final int VK_KANA_LOCK                = 0x0106;

    /**
     * Constant for the input method on/off key.
     * @since 1.3
     */
    /* Japanese PC 106 keyboard: kanji. Japanese Solaris keyboard: nihongo */
    public static final int VK_INPUT_METHOD_ON_OFF      = 0x0107;

    /* for Sun keyboards */
    /** @since 1.2 */
    public static final int VK_CUT                      = 0xFFD1;
    /** @since 1.2 */
    public static final int VK_COPY                     = 0xFFCD;
    /** @since 1.2 */
    public static final int VK_PASTE                    = 0xFFCF;
    /** @since 1.2 */
    public static final int VK_UNDO                     = 0xFFCB;
    /** @since 1.2 */
    public static final int VK_AGAIN                    = 0xFFC9;
    /** @since 1.2 */
    public static final int VK_FIND                     = 0xFFD0;
    /** @since 1.2 */
    public static final int VK_PROPS                    = 0xFFCA;
    /** @since 1.2 */
    public static final int VK_STOP                     = 0xFFC8;
    
    /**
     * Constant for the Compose function key.
     * @since 1.2
     */
    public static final int VK_COMPOSE                  = 0xFF20;
 
    /**
     * Constant for the AltGraph function key.
     * @since 1.2
     */
    public static final int VK_ALT_GRAPH                = 0xFF7E;

    /**
     * This value is used to indicate that the keyCode is unknown.
     * KEY_TYPED events do not have a keyCode value; this value 
     * is used instead.  
     */
    public static final int VK_UNDEFINED      = 0x0;

    /**
     * KEY_PRESSED and KEY_RELEASED events which do not map to a
     * valid Unicode character use this for the keyChar value.
     */
    public static final char CHAR_UNDEFINED   = 0xFFFF;

    /**
     * A constant indicating that the keyLocation is indeterminate
     * or not relevant.
     * KEY_TYPED events do not have a keyLocation; this value
     * is used instead.
     * @since 1.4
     */
  // public static final int KEY_LOCATION_UNKNOWN  = 0;

    /**
     * A constant indicating that the key pressed or released
     * is not distinguished as the left or right version of a key,
     * and did not originate on the numeric keypad (or did not
     * originate with a virtual key corresponding to the numeric
     * keypad).
     * @since 1.4
     */
  // public static final int KEY_LOCATION_STANDARD = 1;

    /**
     * A constant indicating that the key pressed or released is in
     * the left key location (there is more than one possible location
     * for this key).  Example: the left shift key.
     * @since 1.4
     */
  // public static final int KEY_LOCATION_LEFT     = 2;

    /**
     * A constant indicating that the key pressed or released is in
     * the right key location (there is more than one possible location
     * for this key).  Example: the right shift key.
     * @since 1.4
     */
  // public static final int KEY_LOCATION_RIGHT    = 3;

    /**
     * A constant indicating that the key event originated on the
     * numeric keypad or with a virtual key corresponding to the
     * numeric keypad.
     * @since 1.4
     */
  // public static final int KEY_LOCATION_NUMPAD   = 4;

    /** 
     * Stores the state of native event dispatching system
     * - true, if when the event was created event proxying 
     *         mechanism was active
     * - false, if it was inactive
     * Used in Component.dispatchEventImpl to correctly dispatch
     * events when proxy is active
     */
    // PBP/PP 6205227
    //private boolean isProxyActive;

    /** 
     * The unique value assigned to each of the keys on the
     * keyboard.  There is a common set of key codes that
     * can be fired by most keyboards.
     * The symbolic name for a key code should be used rather
     * than the code value itself.
     *
     * @serial
     * @see #getKeyCode()
     * @see #setKeyCode(int)
     */
     int keyCode;

    /** 
     * <code>keyChar</code> is a valid unicode character
     * that is fired by a key or a key combination on
     * a keyboard.
     *
     * @serial
     * @see #getKeyChar()
     * @see #setKeyChar(char)
     */
     char keyChar;

    /** 
     * The location of the key on the keyboard.
     *
     * Some keys occur more than once on a keyboard, e.g. the left and
     * right shift keys.  Additionally, some keys occur on the numeric
     * keypad.  This variable is used to distinguish such keys.
     *
     * The only legal values are <code>KEY_LOCATION_UNKNOWN</code>, 
     * <code>KEY_LOCATION_STANDARD</code>, <code>KEY_LOCATION_LEFT</code>, 
     * <code>KEY_LOCATION_RIGHT</code>, and <code>KEY_LOCATION_NUMPAD</code>.
     *
     * @serial
     * @see #getKeyLocation()
     */
  // int keyLocation;

    /*
     * JDK 1.1 serialVersionUID 
     */
    private static final long serialVersionUID = -2352130953028126954L;

//     public KeyEvent(Component source, int id, long when, int modifiers, int
//         keyCode, char keyChar, int keyLocation)
//     { super(null, 0, 0, 0); }

    /** 
     * Constructs a <code>KeyEvent</code> object.
     * <p>Note that passing in an invalid <code>id</code> results in
     * unspecified behavior.
     *
     * @param source    the <code>Component</code> that originated the event
     * @param id        an integer identifying the type of event
     * @param when      a long integer that specifies the time the event
     *                  occurred
     * @param modifiers the modifier keys down during event (shift, ctrl,
     *                  alt, meta)
     *                  Either extended _DOWN_MASK or old _MASK modifiers
     *                  should be used, but both models should not be mixed
     *                  in one event. Use of the extended modifiers is
     *                  preferred.
     * @param keyCode   the integer code for an actual key, or VK_UNDEFINED 
     *                  (for a key-typed event)
     * @param keyChar   the Unicode character generated by this event, or 
     *                  CHAR_UNDEFINED (for key-pressed and key-released
     *                  events which do not map to a valid Unicode character)
     * @exception IllegalArgumentException  if <code>id</code> is
     *     <code>KEY_TYPED</code> and <code>keyChar</code> is
     *     <code>CHAR_UNDEFINED</code>; or if <code>id</code> is
     *     <code>KEY_TYPED</code> and <code>keyCode</code> is not
     *     <code>VK_UNDEFINED</code>
     */
    public KeyEvent(Component source, int id, long when, int modifiers, int
        keyCode, char keyChar)
    { super(null, 0, 0, 0); }

    /** 
     * @deprecated as of JDK1.1 
     */
//     public KeyEvent(Component source, int id, long when, int modifiers, int
//         keyCode)
//     { super(null, 0, 0, 0);}

  // PBP/PP
  // [6238261]
  // This method needs to be restored from JDK 1.3.1 since
  // AWTEvent.setSource() is not present.
    /**
     * Set the source of this KeyEvent. Dispatching this event subsequent
     * to this operation will send this event to the new Object.
     *
     * @param newSource the KeyEvent's new source.
     */
    public void setSource(Object newSource) {}

    /** 
     * Returns the integer keyCode associated with the key in this event.
     * 
     * @return the integer code for an actual key on the keyboard. 
     *         (For <code>KEY_TYPED</code> events, the keyCode is 
     *         <code>VK_UNDEFINED</code>.)
     */
    public int getKeyCode() { return 0;}

    /** 
     * Set the keyCode value to indicate a physical key.
     *
     * @param keyCode an integer corresponding to an actual key on the keyboard.
     */
    public void setKeyCode(int keyCode) { }

    /** 
     * Returns the character associated with the key in this event.
     * For example, the key-typed event for shift + "a" returns the 
     * value for "A".
     *
     * @return the Unicode character defined for this key event.
     *         If no valid Unicode character exists for this key event, 
     *         keyChar is <code>CHAR_UNDEFINED</code>.
     */
    public char getKeyChar() { return 0; }

    /** 
     * Set the keyChar value to indicate a logical character.
     *
     * @param keyChar a char corresponding to to the combination of keystrokes
     *                that make up this event.
     */
    public void setKeyChar(char keyChar) { }

    /** 
     * Set the modifiers to indicate additional keys that were held down
     * (e.g. shift, ctrl, alt, meta) defined as part of InputEvent.
     * <p>
     * NOTE:  use of this method is not recommended, because many AWT
     * implementations do not recognize modifier changes.  This is
     * especially true for <code>KEY_TYPED</code> events where the shift 
     * modifier is changed.
     *
     * @param modifiers an integer combination of the modifier constants.
     * @see InputEvent
     * @deprecated as of JDK1.1.4
     */
  // public void setModifiers(int modifiers) { }

    /** 
     * Returns the location of the key that originated this key event.
     *
     * Some keys occur more than once on a keyboard, e.g. the left and
     * right shift keys.  Additionally, some keys occur on the numeric
     * keypad.  This provides a way of distinguishing such keys.
     *
     * @return the location of the key that was pressed or released.
     *         Always returns <code>KEY_LOCATION_UNKNOWN</code> for 
     *         <code>KEY_TYPED</code> events.
     * @since 1.4
     */
  // public int getKeyLocation() { return 0;}

    /** 
     * Returns a String describing the keyCode, such as "HOME", "F1" or "A".
     * These strings can be localized by changing the awt.properties file.
     *
     * @return a string containing a text description for a physical key,
     *         identified by its keyCode
     */
    public static String getKeyText(int keyCode) {return null; }

    /** 
     * Returns a String describing the modifier key(s), such as "Shift",
     * or "Ctrl+Shift".  These strings can be localized by changing the 
     * awt.properties file.
     *
     * @return string a text description of the combination of modifier
     *                keys that were held down during the event
     */
    public static String getKeyModifiersText(int modifiers) {return null; }

    /** 
     * Returns whether the key in this event is an "action" key.
     * Typically an action key does not fire a unicode character and is
     * not a modifier key.
     *
     * @return <code>true</code> if the key is an "action" key,
     *         <code>false</code> otherwise
     */
    public boolean isActionKey() { return false; }

    /** 
     * Returns a parameter string identifying this event.
     * This method is useful for event logging and for debugging.
     *
     * @return a string identifying the event and its attributes
     */
    public String paramString() {return null; }

    /** 
     * Sets new modifiers by the old ones. The key modifiers 
     * override overlaping mouse modifiers.
     * @serial
     */
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException
    { }
}
