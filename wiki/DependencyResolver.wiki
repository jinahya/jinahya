#summary Small dependency resolving helper class.

= Introduction =

A simple dependency resolving utility.

= Apidocs =
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-4/apidocs/index.html 1.0-alpha-4]

= Details =

This is a very simple dependency resolving utility.

For following dependency rules,
  * A depends on B and C (A depends on B and A also depends on C)
  * B depends on F
  * C depends on G
  * H depends on B
  * I depends on J and K
  * L depends on K
  * M depends on nothing
  * N depends on nothing
  * O depends on P and Q
  * P and Q depend on R (P depnds on R and Q depends on R)
which can be presented like this.
<wiki:comment>←↑→↓↖↗↘↙</wiki:comment>
{{{
    H
    ↓
  ↗ B → F
A
  ↘ C → G
}}}
{{{
  ↗ J
U
  ↘ K ← L
}}}
{{{
M → null

N → null

  ↗ Q ↘
P       R
  ↘ R ↗
}}}

You can construct a dependency resolver as follows.
{{{
final DependencyResolver<String> resolver =
    new DependencyResolver<String>();
resolver.addDependencies("A", "B", "C"); // single source to multiple targets
resolver.addDependency("B", "F"); // single source to single target
resolver.addDependencies("C", "G", null);
resolver.addDependency("H", "B");
resolver.addDependencies("I", "J", "K");
resolver.addDependency("L", "K");
resolver.addDependency("M", null); // null single target is allowed
resolver.addDependency("N", null);
resolver.addDependencies("O", "P", "Q");
resolver.addDependency("P", "R");
resolver.addDependencies("Q", "R");
// resolver.addDependencies("?", (String[]) null); // NPE
}}}
So, what can we do with it?
You can get a single list which is ordered as dependencies.
{{{
final List<String> single = resolver.getSingleGroup();
// single: [F, B, G, C, A, K, L, H, X, J, I]
}}}
And you can get a *_horizontal_* groups. Which means every *_group must be processed sequentially_* but *_each element in a group can be processed concurrently_*.
{{{
final List<List<String>> groups = resolver.getHorizontalGroups();
// horizontal: [[J, N, M, K, G, F, R], [I, L, C, B, P, Q], [H, O, A]]
}}}
You can also get a *_vertical_* groups. Which means each *_group can be processed concurrently_*  but all *_elements in a group must be processed in order_*.
{{{
final List<List<String>> groups = resolver.getVerticalGroups();
// vertical: [[R, Q, P, O], [F, B, G, C, A, H], [K, L, J, I], [M], [N]]
}}}