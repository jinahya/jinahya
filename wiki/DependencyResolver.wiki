#summary A Simple dependency-resolving helper class.
#labels Featured,Phase-Implementation

= Introduction =

A simple dependency resolving utility.

= Apidocs =
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-8/apidocs/index.html 1.0-alpha-8]
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-7/apidocs/index.html 1.0-alpha-7]
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-6/apidocs/index.html 1.0-alpha-6]
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-5/apidocs/index.html 1.0-alpha-5]
  * [http://jinahya.googlecode.com/svn/site/com.googlecode.jinahya/dependency-resolver/1.0-alpha-4/apidocs/index.html 1.0-alpha-4]

= Details =

This is a very simple dependency resolving utility.

<wiki:comment>←↑→↓↖↗↘↙</wiki:comment>
For following dependency rules,
  * A depends on B and C (A depends on B and A also depends on C)
  * B depends on F
  * C depends on G
  * H depends on B
{{{
    H
    ↓
  ↗ B → F
A
  ↘ C → G
}}}
  * I depends on J and K
  * L depends on K
{{{
  ↗ J
I
  ↘ K ← L
}}}
  * M depends on nothing
{{{
M → null
}}}
  * N depends on nothing
{{{
N → null
}}}
  * O depends on P and Q
  * P and Q depend on R (P depnds on R and Q depends on R)
{{{
  ↗ Q ↘
P       R
  ↘ R ↗
}}}

You can construct a dependency resolver as follows.
{{{
final DependencyResolver<String> resolver =
    new DependencyResolver<String>();

resolver.addDependencies("A", "B", "C"); // single source to multiple targets
resolver.addDependency("B", "F"); // single source to single target
resolver.addDependencies("C", "G", null);
resolver.addDependency("H", "B");

resolver.addDependencies("I", "J", "K");
resolver.addDependency("L", "K");

resolver.addDependency("M", null); // null single target is allowed

resolver.addDependency("N", null);

resolver.addDependencies("O", "P", "Q");
resolver.addDependency("P", "R");
resolver.addDependencies("Q", "R");

// resolver.addDependencies("?", (String[]) null); // NPE
}}}
So, what can we do with it?
You can get a single list which is ordered as dependencies.
{{{
final List<String> single = resolver.getSingleGroup();
-> [R, Q, P, F, B, G, C, A, K, L, M, N, O, H, J, I]
}}}
And you can get a *_list of vertical groups_*. Which means *_all groups must be processed sequentially_* but *_each element in a group can be processed concurrently_*.
{{{
final List<List<String>> groups = resolver.getVerticalGroups();
-> [[J, N, M, K, G, F, R], [I, L, C, B, P, Q], [H, O, A]]
}}}
You can also get a *_list of horizontal groups_*. Which means *_each group can be processed concurrently_*  but *_all elements in a group must be processed in order_*.
{{{
final List<List<String>> groups = resolver.getHorizontalGroups();
-> [[R, Q, P, O], [F, B, G, C, A, H], [K, L, J, I], [M], [N]]
}}}